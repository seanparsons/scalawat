<!DOCTYPE html SYSTEM "about:legacy-compat">
<html>
      <head>
        <title>Scala. Wat. — Combined Pages</title>
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/blueprint/screen.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/blueprint/grid.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/blueprint/print.css"></link> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/>
        <![endif]-->
        <link type="text/css" media="screen, projection" rel="stylesheet" href="css/pamflet.css"></link>
        <link type="text/css" media="print" rel="stylesheet" href="css/pamflet-print.css"></link>
        <link type="text/css" media="screen and (min-device-width: 800px), projection" rel="stylesheet" href="css/pamflet-grid.css"></link>
        
        <script src="js/jquery-1.6.2.min.js"></script>
        <script src="js/jquery.collapse.js"></script>
        <script src="js/pamflet.js"></script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"></link><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <meta charset="utf-8"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
        
      </head>
      <body>
        <a class="page prev nav" href="Contents+in+Depth.html">
            <span class="space">&nbsp;</span>
            <span class="flip">❧</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="top nav span-16 title">
              <span>Scala. Wat.</span> — Combined Pages
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <div class="tocwrapper show">
      <a class="tochead nav" style="display: none" href="#toc">❦</a>
      <a name="toc"></a>
      <h4 class="toctitle">Contents</h4>
      <div class="tocbody">
      <div><a href="#Scala.+Wat.">Scala. Wat.</a></div><ol class="toc"> <li><div><a href="#What+Is+Scala%3F">What Is Scala?</a></div></li><li><div><a href="#Code+Along+With+Me">Code Along With Me</a></div></li><li><div><a href="#Values%2C+Variables+And+Functions">Values, Variables And Functions</a></div><ol class="toc"> <li><div><a href="#Values+and+variables">Values and variables</a></div></li><li><div><a href="#Functions">Functions</a></div></li><li><div><a href="#Function+Parameters">Function Parameters</a></div></li><li><div><a href="#Function+Parameters+On+Demand">Function Parameters On Demand</a></div></li><li><div><a href="#If+Statements">If Statements</a></div></li><li><div><a href="#Expressions">Expressions</a></div></li><li><div><a href="#Type+Inference">Type Inference</a></div></li> </ol></li><li><div><a href="#Classes+And+Things">Classes And Things</a></div><ol class="toc"> <li><div><a href="#Classes">Classes</a></div></li><li><div><a href="#Traits">Traits</a></div></li><li><div><a href="#Case+Classes">Case Classes</a></div></li><li><div><a href="#Using+Case+Classes">Using Case Classes</a></div></li><li><div><a href="#Objects">Objects</a></div></li><li><div><a href="#Object+Inheritance">Object Inheritance</a></div></li><li><div><a href="#Companion+Objects">Companion Objects</a></div></li><li><div><a href="#Generics">Generics</a></div></li><li><div><a href="#Generic+Constraints">Generic Constraints</a></div></li><li><div><a href="#Tuples">Tuples</a></div></li> </ol></li><li><div><a href="#Collections">Collections</a></div><ol class="toc"> <li><div><a href="#Lists">Lists</a></div></li><li><div><a href="#Sets">Sets</a></div></li><li><div><a href="#Vector">Vector</a></div></li><li><div><a href="#Maps">Maps</a></div></li><li><div><a href="#Option">Option</a></div></li><li><div><a href="#The+map+Method">The map Method</a></div></li><li><div><a href="#The+flatMap+Method">The flatMap Method</a></div></li><li><div><a href="#Why+Flatmap%3F">Why Flatmap?</a></div></li><li><div><a href="#Using+flatMap+With+Option">Using flatMap With Option</a></div></li><li><div><a href="#Fold+To+The+Left">Fold To The Left</a></div></li><li><div><a href="#Everything+Is+A+Fold">Everything Is A Fold</a></div></li><li><div><a href="#For+Loops">For Loops</a></div></li><li><div><a href="#For+Comprehensions">For Comprehensions</a></div></li><li><div><a href="#Nesting+For+Comprehensions">Nesting For Comprehensions</a></div></li><li><div><a href="#Filtering+For+Comprehensions">Filtering For Comprehensions</a></div></li><li><div><a href="#Making+For+Comprehensions">Making For Comprehensions</a></div></li><li><div><a href="#Collections+Do+Much+More">Collections Do Much More</a></div></li> </ol></li><li><div><a href="#Pattern+Matching">Pattern Matching</a></div><ol class="toc"> <li><div><a href="#Basic+Pattern+Matching">Basic Pattern Matching</a></div></li><li><div><a href="#Pattern+Matching+On+Types">Pattern Matching On Types</a></div></li><li><div><a href="#Guards%21">Guards!</a></div></li><li><div><a href="#Pattern+Matching+Fields">Pattern Matching Fields</a></div></li><li><div><a href="#Multiple+Pattern+Matches">Multiple Pattern Matches</a></div></li><li><div><a href="#Case.*">Case.*</a></div></li><li><div><a href="#Partial+Functions">Partial Functions</a></div></li><li><div><a href="#Exceptions">Exceptions</a></div></li><li><div><a href="#Implementing+Unapply">Implementing Unapply</a></div></li> </ol></li><li><div><a href="#Typeclasses">Typeclasses</a></div><ol class="toc"> <li><div><a href="#What+is+a+typeclass%3F">What is a typeclass?</a></div></li><li><div><a href="#Is+that+really+a+typeclass%3F">Is that really a typeclass?</a></div></li><li><div><a href="#But+Scala+isn%E2%80%99t+Haskell.">But Scala isn’t Haskell.</a></div></li><li><div><a href="#What%E2%80%99s+that+doing%3F">What’s that doing?</a></div></li><li><div><a href="#How+is+that+useful%3F">How is that useful?</a></div></li><li><div><a href="#Stock+Typeclasses%3A+Functor">Stock Typeclasses: Functor</a></div></li><li><div><a href="#Stock+Typeclasses%3A+Applicative+Functor">Stock Typeclasses: Applicative Functor</a></div></li><li><div><a href="#Stock+Typeclasses%3A+Monad">Stock Typeclasses: Monad</a></div></li><li><div><a href="#Stock+Typeclasses%3A+Monoid">Stock Typeclasses: Monoid</a></div></li><li><div><a href="#Stock+Typeclasses%3A+Summary">Stock Typeclasses: Summary</a></div></li><li><div><a href="#Stock+Typeclasses%3A+Using+Them">Stock Typeclasses: Using Them</a></div></li> </ol></li><li><div><a href="#Other+Things+You+May+See">Other Things You May See</a></div><ol class="toc"> <li><div><a href="#Nothing">Nothing</a></div></li><li><div><a href="#Underscores">Underscores</a></div></li><li><div><a href="#Currying+And+Partial+Application">Currying And Partial Application</a></div></li><li><div><a href="#Either">Either</a></div></li><li><div><a href="#Java+Interop">Java Interop</a></div></li> </ol></li><li><div><a href="#Actors">Actors</a></div><ol class="toc"> <li><div><a href="#What%E2%80%99s+an+actor%3F">What’s an actor?</a></div></li><li><div><a href="#What+If+I+Want+A+Result%3F">What If I Want A Result?</a></div></li><li><div><a href="#Don%E2%80%99t+Block%21">Don’t Block!</a></div></li><li><div><a href="#Where+Would+I+Use+Actors%3F">Where Would I Use Actors?</a></div></li> </ol></li><li><div><a href="#SBT">SBT</a></div><ol class="toc"> <li><div><a href="#Getting+SBT+Installed">Getting SBT Installed</a></div></li><li><div><a href="#SBT+Basics">SBT Basics</a></div></li> </ol></li> </ol></div></div><h1 id="Scala.+Wat.">Scala. Wat.</h1><p>A presentation about Scala and the core of how to use it.</p><h1 id="What+Is+Scala%3F">What Is Scala?</h1><ul><li>Runs on the JVM and produces bytecode.
</li><li>Scala can use Java, Java can use Scala.
</li><li>Commercially supported and developed by <a  href="http://typesafe.com/">TypeSafe</a>.</li></ul><h1 id="Code+Along+With+Me">Code Along With Me</h1><p>To play with some of the snippets there are a few options:
</p><ul><li>Install the <a  href="http://typesafe.com/stack">Typesafe Stack</a>, to run scala on the command line.
</li><li>With <a  href="http://mxcl.github.com/homebrew/">Homebrew</a>: brew install scala
</li><li>If you have <a  href="https://github.com/harrah/xsbt">SBT</a>: sbt console</li></ul><h1 id="Values%2C+Variables+And+Functions">Values, Variables And Functions</h1><p>In which we explore values, variables and functions.</p><h1 id="Values+and+variables">Values and variables</h1><p>A value is a field that can’t be updated after assignment.
</p><pre><code class="prettyprint lang-scala">val foo: Int = 2
// foo = 3 wouldn't compile.
</code></pre><p>A variable is a field that can be updated after assignment.
</p><pre><code class="prettyprint lang-scala">var foo: Int = 2
foo = 3
</code></pre><p>Also these can be made lazy.
</p><pre><code class="prettyprint lang-scala">lazy val foo: Int = 10 // Imagine this took a minute to calculate.
</code></pre><h1 id="Functions">Functions</h1><p>We can define a function using the def keyword.
</p><pre><code class="prettyprint lang-scala">def square(number: Int): Int = {
  number * number
}
</code></pre><p>Note that we don’t need to use the return keyword, the last expression is taken as the result of the method.
<br/>
<br/>
As functions are first class elements in Scala, they can be assigned to a field or passed into other methods.
</p><pre><code class="prettyprint lang-scala">val squareFunction: (Int) =&gt; Int = square
// Alternatively:
// val squareFunction = (number: Int) =&gt; number * number
</code></pre><h1 id="Function+Parameters">Function Parameters</h1><p>Multiple parameters as well as varargs are supported.
</p><pre><code class="prettyprint lang-scala">def printAtLeastOneKitteh(firstKitteh: String, kittehs: String*) {
  println(firstKitteh)
  println(kittehs)
}
printAtLeastOneKitteh(&quot;Spot&quot;, &quot;Rover&quot;, &quot;Jeff&quot;)
</code></pre><p>Also it’s possible to use multiple parameter groups.
</p><pre><code class="prettyprint lang-scala">def printKittehs(firstKitteh: String)(otherKittehs: String*) {
  println(firstKitteh)
  println(otherKittehs)
}
printKittehs(&quot;Spot&quot;)(&quot;Rover&quot;, &quot;Jeff&quot;)
</code></pre><p>Methods that have no parameters to them (like one form of println) can have the parenthesis omitted.
</p><h1 id="Function+Parameters+On+Demand">Function Parameters On Demand</h1><pre><code class="prettyprint lang-scala">def printLater(was: Long, now: =&gt; Long): Unit = {
  Thread.sleep(100)
  println(&quot;Was: &quot; + was + &quot; Now: &quot; + now)
}

printLater(System.currentTimeMillis, System.currentTimeMillis)
// Was: 1336129701612 Now: 1336129701714
</code></pre><p>The now expression is executed at the point when it’s used inside the method, not when it’s passed into the method.
<br/>
<br/>
Note that the “now” parameter is effectively a function that lacks parameters and parenthesis.
</p><h1 id="If+Statements">If Statements</h1><p>If statements function slightly differently to languages like Java, think of them more like a method themselves as they return a value.
</p><pre><code class="prettyprint lang-java">// Java.
String someValue = null;
if (1 == 1) {
  someValue = &quot;1 is definitely 1.&quot;;
} else {
  someValue = &quot;Maths is broken, the end is nigh.&quot;;
}
</code></pre><pre><code class="prettyprint lang-scala">// Scala.
val someValue: String = if (1 == 1) {
  &quot;1 is definitely 1.&quot;
} else {
  &quot;Maths is broken, the end is nigh.&quot;
}
</code></pre><h1 id="Expressions">Expressions</h1><p>Scala is quite flexible in its use of expressions.
</p><pre><code class="prettyprint lang-scala">val someOfTheText = {
  val text = &quot;Some really long text...&quot;
  new String(text.substring(5, 12))
}
println(someOfTheText)
println{
  someOfTheText
}
</code></pre><p>Even the contents of a function are an expression:
</p><pre><code class="prettyprint lang-scala">def square(number: Int): Int = (number * number)
</code></pre><h1 id="Type+Inference">Type Inference</h1><p>Scala supports type inference on fields:
</p><pre><code class="prettyprint lang-scala">val number = 1
println(number.getClass)
</code></pre><p>It also supports type inference for method return types:
</p><pre><code class="prettyprint lang-scala">def getRandomNumber() = 4
var number = getRandomNumber()
// This would not compile, as the type of number is Int.
// number = &quot;Test&quot;
</code></pre><h1 id="Classes+And+Things">Classes And Things</h1><p>In which we explore classes, traits and objects.</p><h1 id="Classes">Classes</h1><p>Much like other languages a class tends to encapsulate some data and expose some methods for interacting with it.
</p><pre><code class="prettyprint lang-scala">class Monkey(var x: Int, var y: Int) {
  def this() = this(0, 0)        // Overloaded constructor.
  println(&quot;Creating a monkey!&quot;)  // Wut?
  def move(xMovement: Int, yMovement: Int): Unit = {
    x += xMovement
    y += yMovement
  }
}
</code></pre><h1 id="Traits">Traits</h1><p>Traits can be used like interfaces in Java, with the exception that they can also include code, values and variables as well.
</p><pre><code class="prettyprint lang-scala">trait Logging {
  def log(logLevel: String, message: String): Unit
  def info(message: String) {
    log(&quot;INFO&quot;, message)
  }
}

class Monkey extends Logging {
  def log(logLevel: String, message: String) {
    println(logLevel + &quot;: &quot; + message)
  }
  def throwBanana() {
    // Something else happens.
    info(&quot;Banana thrown.&quot;)
  }
}
val monkey = new Monkey()
monkey.throwBanana()
</code></pre><h1 id="Case+Classes">Case Classes</h1><p>The case keyword provides a whole load of awesome.
</p><pre><code class="prettyprint lang-scala">case class Monkey(x: Int, y: Int)
</code></pre><p>From this we get:
</p><ul><li>Fields that default to being immutable (can prefix with var)
</li><li>equals, hashCode, toString implementations.
</li><li>A copy method for conveniently creating new instances.
</li><li>The class implements Serializable.
</li><li>And more…
</li></ul><h1 id="Using+Case+Classes">Using Case Classes</h1><p>Lets have a look at some of that.
</p><pre><code class="prettyprint lang-scala">val monkey1 = new Monkey(0, 0)
val movedMonkey1 = monkey1.copy(x = 10)
println(monkey1)
println(monkey1 == movedMonkey1)
</code></pre><p>Note that we used ”==” rather than equals, the method ”==” is a null safe alias of equals(…) from Java. To check for reference equality, use the eq method.</p><h1 id="Objects">Objects</h1><p>Scala has singletons built into the language.
</p><pre><code class="prettyprint lang-scala">object CakeConcatenator {
  val cake = &quot;CAKE!!&quot;
  def concatenate(text: String): String = text + cake
}

println(CakeConcatenator.cake)
println(CakeConcatenator.concatenate(&quot;I must have &quot;))
</code></pre><p>Not possible to “new” up an object.</p><h1 id="Object+Inheritance">Object Inheritance</h1><p>Objects can extend classes and/or traits.
</p><pre><code class="prettyprint lang-scala">trait Concatenator {
  def concatenate(text: String): String
}

object CakeConcatenator extends Concatenator {
  val cake = &quot;CAKE!!&quot;
  def concatenate(text: String): String = text + cake
}
</code></pre><h1 id="Companion+Objects">Companion Objects</h1><p>Scala allows a class and an object with the same name to co-exist.
</p><pre><code class="prettyprint lang-scala">class Cake(name: String)
object Cake {
  def apply(name: String) = new Cake(name)
}
val cake = Cake(&quot;Chocolate&quot;)
</code></pre><p>Case classes do this too:
</p><pre><code class="prettyprint lang-scala">case class Cake(name: String)
val cake = Cake(&quot;Chocolate&quot;)
</code></pre><h1 id="Generics">Generics</h1><p>Scala supports generics almost identically to Java.
</p><pre><code class="prettyprint lang-scala">trait Serializer[T] { 
  def serialize(target: T): Array[Byte]
}

object StringSerializer extends Serializer[String] {
  def serialize(target: String) = target.getBytes
}

println(StringSerializer.serialize(&quot;CAKE!&quot;))

</code></pre><p>Methods can also be generified (note this may not be a real word).</p><h1 id="Generic+Constraints">Generic Constraints</h1><p>Generic types can have type bounds, which place certain constraints on what types can be used.
</p><pre><code class="prettyprint lang-scala">import java.io._

trait Serializer[T &lt;: Serializable] { 
  def serialize(target: T): Array[Byte] = {
    // Stock Java &quot;Serializable&quot; style serialization.
    val byteArrayOutputStream = new ByteArrayOutputStream()
    val objectOutputStream = new ObjectOutputStream(byteArrayOutputStream)
    objectOutputStream.writeObject(target)
    val bytes = byteArrayOutputStream.toByteArray()
    objectOutputStream.close()
    bytes
  }
}

object StringSerializer extends Serializer[String]

println(StringSerializer.serialize(&quot;CAKE!&quot;))

</code></pre><h1 id="Tuples">Tuples</h1><p>Scala has a series of tuples that are somewhat like nameless classes.
</p><pre><code class="prettyprint lang-scala">val tuple2 = new Tuple2(&quot;Another Test&quot;, 4)
println(tuple2)
println(tuple2._2)
val tuple3 = (1, &quot;Test&quot;, 2.7)
println(tuple3)
println(tuple3._3)
</code></pre><p>Since creating a case class is so simple (and worry free), lean towards creating those for method parameters and return types.</p><h1 id="Collections">Collections</h1><p>In which we explore the world of Sets, Lists and Maps.
<br/>
<br/>
For much more information, the <a  href="http://www.scala-lang.org/docu/files/collections-api/collections_0.html">collections API docs</a> are the best place to start.</p><h1 id="Lists">Lists</h1><p>A List is a series of items sequentially stored.
</p><pre><code class="prettyprint lang-scala">val list = List(5, 6, 1)
println(list)
println(list.head)
println(list.tail)
</code></pre><p>The stock List implementation is a <a  href="http://en.wikipedia.org/wiki/Cons">cons</a>-list, each part of the list consists of an element(head) and another list(tail).
</p><pre><code class="prettyprint lang-scala">// Alternatively:
val list = 5 :: 6 :: 1 :: Nil
// To show the structure.
val list = (5 :: (6 :: (1 :: Nil)))
</code></pre><h1 id="Sets">Sets</h1><p>A Set is a collection of elements with no duplicates, ordering cannot be guaranteed.
</p><pre><code class="prettyprint lang-scala">val set = Set(1, 2, 7, 1) 
println(set)
println(set.head)
println(set.tail)
println(set + 25) // Creates new instance.
</code></pre><h1 id="Vector">Vector</h1><p>A more general sequential type is Vector, which provides amortised constant time operations for prepending and appending amongst other things.
</p><pre><code class="prettyprint lang-scala">val vector = Vector(1, 9, 22, 19, -5, 10)
println(vector :+ 3)
println(7 +: vector)
println(vector.patch(3, Vector(1, 2, 3, 4), 0))
</code></pre><p>Note that pretty much all the methods seen on Set/List/Vector are inherited from <a  href="http://www.scala-lang.org/api/current/scala/collection/Seq.html">Seq</a>(there’s a lot more too), so all of them will work in the same way. 
</p><h1 id="Maps">Maps</h1><p>A Map is otherwise known as an associative array or dictionary. It just stores values against keys, with the keys being unique.
</p><pre><code class="prettyprint lang-scala">val map = Map(1 -&gt; &quot;Sean&quot;, 2 -&gt; &quot;Cat&quot;)
println(map)
println(map(1))              // apply method.
println(map(2))
println(map + (3 -&gt; &quot;Greg&quot;)) // Creates new instance.
println(map.tail)            // Wait, what?
</code></pre><h1 id="Option">Option</h1><p>An Option contains either zero or 1 items, represented by the None and Some types respectively.
</p><pre><code class="prettyprint lang-scala">val potentialValue1: Option[String] = None
val potentialValue2: Option[String] = Some(&quot;Potential!&quot;)
println(potentialValue1)
// None
println(potentialValue2)
// Some(Potential!)
println(potentialValue1.getOrElse(&quot;No Potential!&quot;))
// No Potential!
println(potentialValue2.getOrElse(&quot;No Potential!&quot;))
// Potential!
</code></pre><pre><code class="prettyprint lang-scala">def lookupUser(id: Int): Option[String] = {
  if (id == 1) Some(&quot;Sean&quot;) else None
}
</code></pre><h1 id="The+map+Method">The map Method</h1><p>All of the collections (including Option and even Map) we’ve seen so far support the map method.
</p><pre><code class="prettyprint lang-scala">def timesTwo(number: Int): Int = number * 2

val list = List(10, 20, 30)
println(list.map(timesTwo))
// List(20, 40, 60)

val set = Set(9, 10, 23)
println(set.map(timesTwo))
// Set(18, 20, 46)

val some = Some(99)
val none = None
println(some.map(timesTwo))
// Some(198)
println(none.map(timesTwo))
// None
</code></pre><h1 id="The+flatMap+Method">The flatMap Method</h1><p>Works very similar to map, but is way more useful.
</p><pre><code class="prettyprint lang-scala">def lookupScores(playerID: Int): List[Int] = {
  List(playerID, playerID * 2, playerID * 3)
}

println(List(1, 2, 3).map(lookupScores))
// List(List(1, 2, 3), List(2, 4, 6), List(3, 6, 9))
println(List(1, 2, 3).flatMap(lookupScores))
// List(1, 2, 3, 2, 4, 6, 3, 6, 9)
</code></pre><h1 id="Why+Flatmap%3F">Why Flatmap?</h1><p>Hands up if you’ve written a piece of code like this?
</p><pre><code class="prettyprint lang-java">Player player = lookupPlayer(1);
if (player != null) {
  Integer score = lookupScore(player);
  if (score != null) {
    return &quot;Score is: &quot; + score;
  }
}
return null;
</code></pre><p>Lots of boilerplate, easy to get a condition wrong, have to explicitly return (in this case the code is Java). Bear in mind the man who gave us null calls it his <a  href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">Billion Dollar Mistake</a>.
</p><h1 id="Using+flatMap+With+Option">Using flatMap With Option</h1><p>Option and the flatMap method go together really well if we adapt the prior example to use Option in Scala.
</p><pre><code class="prettyprint lang-scala">case class Player(name: String)
def lookupPlayer(id: Int): Option[Player] = {
  if (id == 1) Some(new Player(&quot;Sean&quot;))
  else if(id == 2) Some(new Player(&quot;Greg&quot;))
  else None
}
def lookupScore(player: Player): Option[Int] = {
  if (player.name == &quot;Sean&quot;) Some(1000000) else None
}

println(lookupPlayer(1).map(lookupScore))  // Some(Some(1000000))
println(lookupPlayer(2).map(lookupScore))  // Some(None)
println(lookupPlayer(3).map(lookupScore))  // None

println(lookupPlayer(1).flatMap(lookupScore))  // Some(1000000)
println(lookupPlayer(2).flatMap(lookupScore))  // None
println(lookupPlayer(3).flatMap(lookupScore))  // None
</code></pre><h1 id="Fold+To+The+Left">Fold To The Left</h1><p>The foldLeft method takes an initial value and “folds” over the collection using a function. Summing up a collection is the prime example.
</p><pre><code class="prettyprint lang-java">// Java
Integer[] scores = new Integer[]{200, 300, 600};
int total = 0;
for (Integer score : scores) {
  total += score;
}
return total;
</code></pre><pre><code class="prettyprint lang-scala">// Scala
val scores = List(100, 200, 300)
scores.foldLeft(0)((runningScore, score) =&gt; runningScore + score)
// For those comfortable with the syntax:
scores.foldLeft(0)(_ + _)
// Don't use this:
(0 /: scores)(_ + _)
</code></pre><h1 id="Everything+Is+A+Fold">Everything Is A Fold</h1><p>Methods like map can (and probably are) implemented in terms of a fold.
</p><pre><code class="prettyprint lang-scala">def mapList[T, U](values: List[T], function: T =&gt; U): List[U] = {
  values.foldRight(Nil: List[U]){(value: T, workingList: List[U]) =&gt;
    function(value) :: workingList
  }
}
println(mapList(List(1, 2, 3), 
                (number: Int) =&gt; number.toString + &quot; cakes!&quot;))
// List(1 cakes!, 2 cakes!, 3 cakes!)
</code></pre><h1 id="For+Loops">For Loops</h1><pre><code class="prettyprint lang-java">// Java
for (int count = 0; count &lt; 4; count++) {
  System.out.println(count);
}
</code></pre><pre><code class="prettyprint lang-scala">// Scala
for(count &lt;- 0 until 4) {
  println(count)
}
// Also:
for(count &lt;- List(0, 1, 2, 3)) {
  println(count)
}
</code></pre><h1 id="For+Comprehensions">For Comprehensions</h1><p>Instead of side effecting like a for loop, a for comprehension returns a value.
</p><pre><code class="prettyprint lang-scala">val results = for {
  number &lt;- List(10, 20, 30)
} yield number * 2
println(results)
// List(20, 40, 60)
</code></pre><h1 id="Nesting+For+Comprehensions">Nesting For Comprehensions</h1><pre><code class="prettyprint lang-scala">case class Player(name: String)
def lookupPlayer(id: Int): Option[Player] = {
  if (id == 1) Some(new Player(&quot;Sean&quot;)) else None
}
def lookupScore(player: Player): Option[Int] = {
  if (player.name == &quot;Sean&quot;) Some(1000000) else None
}
val scoreText = for {
  player &lt;- lookupPlayer(1)
  score &lt;- lookupScore(player)
} yield &quot;%s scored %s.&quot;.format(player.name, score)
println(scoreText)
// Some(Sean scored 1000000.)
</code></pre><h1 id="Filtering+For+Comprehensions">Filtering For Comprehensions</h1><p>It’s also possible to filter those collections, so to expand on the previous example.
</p><pre><code class="prettyprint lang-scala">case class Player(name: String, deleted: Boolean)
def lookupPlayer(id: Int): Option[Player] = {
  if (id == 1) Some(new Player(&quot;Sean&quot;, true)) else None
}
def lookupScore(player: Player): Option[Int] = {
  if (player.name == &quot;Sean&quot;) Some(1000000) else None
}
val scoreText = for {
  player &lt;- lookupPlayer(1) if !player.deleted
  score &lt;- lookupScore(player)
} yield &quot;%s scored %s.&quot;.format(player.name, score)
println(scoreText)
// None
</code></pre><h1 id="Making+For+Comprehensions">Making For Comprehensions</h1><p>For comprehensions work by convention, there’s no requirement for them to be a collection.
</p><ul><li>A single layer of nesting requires map to be implemented
</li><li>Multiple layers of nesting, requires map and flatMap to be implemented.
</li><li>If you want to filter items, implement filter.
</li><li>To just loop over elements, implement foreach.</li></ul><h1 id="Collections+Do+Much+More">Collections Do Much More</h1><p><a  href="http://www.scala-lang.org/api/current/scala/collection/Seq.html">Seq</a> is the prime trait for any of the sequential collections (even Map which is why previously there was a map.tail method call).
</p><pre><code class="prettyprint lang-scala">val seq = Seq(-10, -5, 0, 1, 2, 3, 9999)
println(seq.collect{
  case number if number % 2 == 0 =&gt; &quot;Even: &quot; + number
})
println(seq.take(4))
println(seq.drop(4))
println(seq.forall(number =&gt; number % 3 == 0))
println(seq.groupBy(number =&gt; number % 3))
println(seq.max)
println(seq.permutations.toSet)
println(seq.combinations(3).toSet)
println(seq.map(number =&gt; (number % 3, number)).toMap)
println(seq.zip(seq))
</code></pre><h1 id="Pattern+Matching">Pattern Matching</h1><p>In which we explore how matching patterns can make your life easy.</p><h1 id="Basic+Pattern+Matching">Basic Pattern Matching</h1><p>Switch/Case statements are available in a lot of languages, with Scala being no exception.
</p><pre><code class="prettyprint lang-scala">def getPlayerName(id: Int): String = {
  id match {
    case 1 =&gt; &quot;Sean&quot;
    case 2 =&gt; &quot;Greg&quot;
    case _ =&gt; &quot;Unknown&quot;
  }
}

println(getPlayerName(1))
println(getPlayerName(2))
println(getPlayerName(99))
</code></pre><p>Similar to the if statement, the match expression and the cases return a value, so there’s no need for “break;” statements or any such nonsense.</p><h1 id="Pattern+Matching+On+Types">Pattern Matching On Types</h1><p>One step beyond(<a  href="http://www.youtube.com/watch?v=N-uyWAe0NhQ">!</a>) that is matching on types.
</p><pre><code class="prettyprint lang-scala">def whatIsThis(value: Any): String = {
  value match {
    case int: Int =&gt; &quot;It's an Int.&quot;
    case text: String =&gt; &quot;It's a String: &quot; + text
    case _ =&gt; &quot;I don't know what it is.&quot;
  }
}

println(whatIsThis(&quot;Moshi&quot;))
println(whatIsThis(1))
println(whatIsThis(1.2))
</code></pre><h1 id="Guards%21">Guards!</h1><p>Each case can also be given a guard, which is a further condition that it must satisfy for it to match.
</p><pre><code class="prettyprint lang-scala">def parseNumberSafely(id: Int): String = {
  id match {
    case positiveNumber if positiveNumber &gt; 0 =&gt; {
      &quot;This is a positive number of: &quot; + positiveNumber
    }
    case negative =&gt; { 
      &quot;This is not a positive number: &quot; + negative
    }
  }
}

println(parseNumberSafely(1))
println(parseNumberSafely(1000))
println(parseNumberSafely(-200))
println(parseNumberSafely(0))
</code></pre><p>As the compiler knows the type of “id” it’s not necessary to specify it in the case expressions.</p><h1 id="Pattern+Matching+Fields">Pattern Matching Fields</h1><p>It may be necessary to pattern match on a field, potentially one passed into a method.
</p><pre><code class="prettyprint lang-scala">def valueMatchesText(value: Any, expected: String): String = {
  value match {
    case `expected` =&gt; &quot;It worked!&quot;
    case _ =&gt; &quot;It's all gone wrong.&quot;
  }
}
println(valueMatchesText(&quot;One&quot;, &quot;One&quot;))
println(valueMatchesText(1, &quot;One&quot;))
</code></pre><h1 id="Multiple+Pattern+Matches">Multiple Pattern Matches</h1><p>It’s possible to match multiple things in each case statement:
</p><pre><code class="prettyprint lang-scala">def isFourOrFive(value: Any): String = {
  value match {
    case 4 | 5 =&gt; &quot;Is Four Or Five!&quot;
    case _ =&gt; &quot;No Idea!&quot;
  }
}
println(isFourOrFive(4))
println(isFourOrFive(5))
println(isFourOrFive(&quot;Something Else&quot;))
</code></pre><h1 id="Case.*">Case.*</h1><pre><code class="prettyprint lang-scala">case class Player(name: String)
sealed abstract class Act
case class ShotFired(player: Player, x: Int, y: Int) extends Act
case class MedikitUsed(player: Player, percentUsage: Int) extends Act

def describeAction(action: Act): String = {
  action match {
    case ShotFired(Player(player), x, y) =&gt; {
      &quot;%s fired a gun at (%s,%s)&quot;.format(player, x, y)
    }
    case MedikitUsed(Player(player), useAmount) =&gt; { 
      &quot;%s used %s%% of a medikit&quot;.format(player, useAmount)
    }
  }
}
println(describeAction(ShotFired(Player(&quot;Sean&quot;), 100, 150)))
println(describeAction(MedikitUsed(Player(&quot;Sean&quot;), 10)))
</code></pre><h1 id="Partial+Functions">Partial Functions</h1><p>Each case statement is an instance of <a  href="http://www.scala-lang.org/api/current/scala/PartialFunction.html">PartialFunction</a>.
</p><pre><code class="prettyprint lang-scala">val maybeSeven: PartialFunction[Any, String] = {
  case 7 =&gt; &quot;It's Seven!&quot;
}

println(maybeSeven(1)) // Throws exception.
println(maybeSeven(7))
println(maybeSeven.isDefinedAt(1))
println(maybeSeven.isDefinedAt(7))
</code></pre><h1 id="Exceptions">Exceptions</h1><p>Exceptions in Scala function in much the same way as they do in Java.
</p><pre><code class="prettyprint lang-scala">def parseInt(text: String): Option[Int] = {
  try {
    Some(text.toInt)
  } catch {
    case npe: NullPointerException =&gt; None
    case nfe: NumberFormatException =&gt; None
  } finally {
    // Do nothing.
  }
}
println(parseInt(&quot;1&quot;))
println(parseInt(&quot;Test&quot;))
println(parseInt(null))
</code></pre><p>Note that we pattern match on the type of the exception itself, so if the exception is a case class, we can extract values from it and use guards.</p><h1 id="Implementing+Unapply">Implementing Unapply</h1><p>The unapply method is the crux of pattern matching, it’s automatically created for case classes, but it’s easy to make one yourself.
</p><pre><code class="prettyprint lang-scala">case class WebRequest(url: String, get: Boolean, params: Map[String, String])
case object GET {
  def unapply(webRequest: WebRequest): Option[String] = {
    if (webRequest.get) Option(webRequest.url) else None
  }
}

def parseGetRequest(webRequest: WebRequest): String = webRequest match {
  case GET(url) =&gt; &quot;GET request for %s.&quot;.format(url)
  case _ =&gt; &quot;Unknown&quot;
}
println(parseGetRequest(WebRequest(&quot;/test&quot;, true, Map())))
// GET request for /test.
</code></pre><h1 id="Typeclasses">Typeclasses</h1><p>Types of classes?
</p><h1 id="What+is+a+typeclass%3F">What is a typeclass?</h1><p>If you’ve used Java a reasonable amount there’s a prime candidate of how we do things with inheritance:
</p><pre><code class="prettyprint lang-java">public interface Comparable&lt;T&gt; {
    public int compareTo(T o);
}
</code></pre><p>Later on in Java we got this as an alternative:
</p><pre><code class="prettyprint lang-java">public interface Comparator&lt;T&gt; {
    int compare(T o1, T o2);
}
</code></pre><p>The above is probably the closest Java has to typeclasses.
</p><h1 id="Is+that+really+a+typeclass%3F">Is that really a typeclass?</h1><p>Kinda, real typeclasses come from Haskell which has no inheritance of types.
</p><pre><code class="prettyprint lang-haskell">-- Typeclass definition.
class MyComparator a where
    mycompare :: a -&gt; a -&gt; Integer

-- Typeclass instance.
instance MyComparator Integer where  
    mycompare first second = first - second

1 `mycompare` 2
</code></pre><p>The instance of the typeclass just needs to be in scope, no need to “new up” an instance.
</p><h1 id="But+Scala+isn%E2%80%99t+Haskell.">But Scala isn’t Haskell.</h1><p>Typeclasses can be emulated in Scala through the use of implicit conversions and implicit parameters.
</p><pre><code class="prettyprint lang-scala">object MyComparators {
  trait MyComparator[T] {
    def mycompare(first: T, second: T): Int
  }
  implicit val intComp: MyComparator[Int] = new MyComparator[Int] {
    def mycompare(first: Int, second: Int) = first - second
  }
  case class ValueWrapper[T](value: T) {
    def mycompare(other: T)
                 (implicit comparator: MyComparator[T]): Int = {
      comparator.mycompare(value, other)
    }
  }
  implicit def toValueWrapper[T](value: T): ValueWrapper[T] = {
    new ValueWrapper(value)
  }
}
</code></pre><h1 id="What%E2%80%99s+that+doing%3F">What’s that doing?</h1><pre><code class="prettyprint lang-scala">import MyComparators._
println(1.mycompare(2))
// Compile error:
// println(&quot;Cake&quot;.mycompare(&quot;Elephant&quot;))

// The above is the same as doing this:
new ValueWrapper(1).mycompare(2)
// Or what the compiler is doing:
new ValueWrapper(1).mycompare(2)(intComp)
</code></pre><h1 id="How+is+that+useful%3F">How is that useful?</h1><p>Has anyone ever done this?
</p><pre><code class="prettyprint lang-scala">def method1(): Int = 1
def method2(): String = &quot;1&quot;
println(method1() == method2()) // Always going to be false.
</code></pre><p>Comparing different types with equality is an error the compiler can catch.
</p><pre><code class="prettyprint lang-scala">import scalaz._
import Scalaz._
// Doesn't compile.
// println(method1() === method2())
println(1 === 2)
</code></pre><p>The ”===” method is added in the same way to every type with a requirement of an implicit instance of Equal in scope.
</p><h1 id="Stock+Typeclasses%3A+Functor">Stock Typeclasses: Functor</h1><pre><code class="prettyprint lang-scala">trait Functor[F[_]] { self =&gt;
  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
}
</code></pre><p>We know this as the map method that is seen on Seq/Scala/String
</p><pre><code class="prettyprint lang-scala">Functor[List].map(List(1, 2, 3))(number =&gt; number * 2)
</code></pre><h1 id="Stock+Typeclasses%3A+Applicative+Functor">Stock Typeclasses: Applicative Functor</h1><p>Includes Functor (through Apply).
</p><pre><code class="prettyprint lang-scala">trait Applicative[F[_]] extends Apply[F] with Pointed[F] { self =&gt;
  def apply[A, B, C](fa: =&gt; F[A], fb: =&gt; F[B])(f: (A, B) =&gt; C): F[C]
}
</code></pre><p>This is what we can do with that:
</p><pre><code class="prettyprint lang-scala">val result1: Option[String] = &quot;First&quot;.some
val result2: Option[String] = &quot;Post&quot;.some
def combine(first: String, second: String) = first + &quot; &quot; + second
val result = Applicative[Option].apply(result1, result2)(combine)
println(result)     // Some(&quot;First Post&quot;)
// Or:
println(^(result1, result2)(combine))
</code></pre><h1 id="Stock+Typeclasses%3A+Monad">Stock Typeclasses: Monad</h1><pre><code class="prettyprint lang-scala">trait Monad[F[_]] extends Applicative[F] with Bind[F] { self =&gt;
  // No abstract methods, but introduces bind through Bind:
  // def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]
}
</code></pre><p>At this point we have the ability to put a value into a context (F[_] as shown above), as well as perform transformations on values held within contexts like that (through bind and map amongst others).
</p><h1 id="Stock+Typeclasses%3A+Monoid">Stock Typeclasses: Monoid</h1><pre><code class="prettyprint lang-scala">trait Monoid[F] extends Semigroup[F] { self =&gt;
  // Semigroup provides:
  // def append(f1: F, f2: =&gt; F): F
  def zero: F
}
</code></pre><p>The append method is connected up to the |+| method pretty much directly.
</p><pre><code class="prettyprint lang-scala">println(1 |+| 2)       // 3
println(&quot;1&quot; |+| &quot;2&quot;)   // 12
val map1 = Map(1 -&gt; Set(&quot;DJ Quack&quot;), 2 -&gt; Set(&quot;Big Bad Bill&quot;))
val map2 = Map(1 -&gt; Set(&quot;I.G.G.Y.&quot;))
println(map1 |+| map2) // ???
</code></pre><h1 id="Stock+Typeclasses%3A+Summary">Stock Typeclasses: Summary</h1><ul><li>Functor - Maps the value inside the context.
</li><li>Pointed - Puts a value inside a context.
</li><li>Apply - Maps a value inside a context with a function inside the same context.
</li><li>Applicative - Pulls together Apply and Pointed.
</li><li>Bind - Provides a flatMap style method.
</li><li>Monad - Pulls together Applicative and Bind.
</li><li>Semigroup - Provides an append method that combines two instances of the same type.
</li><li>Monoid - Adds a zero value to Semigroup.
</li></ul><h1 id="Stock+Typeclasses%3A+Using+Them">Stock Typeclasses: Using Them</h1><pre><code class="prettyprint lang-scala">// Invert types, turning A[B[C]] into B[A[C]], 
// uses Traverse and Applicative.
println(List(1.some, 2.some, 3.some).sequence)
println(List(1.some, 2.some, none).sequence)

// foldLeft is too much work, uses Monoid and Foldable.
println(List(1, 2, 3).foldMap(_.toString))
println(List(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).foldMap(_.toInt))
</code></pre><h1 id="Other+Things+You+May+See">Other Things You May See</h1><p>In which we explore…Other Things.</p><h1 id="Nothing">Nothing</h1><p>Nothing is a bottom type, which means it extends every type, but doesn’t allow you to create an instance of that type (because that would be a nonsense class).
<br/>
<br/>
The definitions of Some and None might help to clear this up:
</p><pre><code class="prettyprint lang-scala">final case class Some[+A](x: A) extends Option[A] {...}

case object None extends Option[Nothing] {...}
</code></pre><p>As None extends Option[Nothing] it can be used in place of an Option regardless of the type.</p><h1 id="Underscores">Underscores</h1><p>An underscore in scala is used in multiple places, usually to specify the default of something or that the value should be ignored.
</p><pre><code class="prettyprint lang-scala">// Wildcard import.
import java.io._
// Default value for a given type.
var number: Int = _
// Function currying.
def multiplier(i: Int)(factor: Int) = i * factor
val byFive = multiplier(5)_
println(byFive(20))
// Default type.
val list: List[_] = List(1, 2, 3)
// Function parameters.
println(List(1, 2, 3).foldLeft(10)(_ + _))
// Default case parameter:
// case _ =&gt; &quot;Default&quot;
// Collection expansion to varargs:
def printValues(values: Any*) = values.foreach(println)
printValues(List(1, 2, 3): _*)
</code></pre><h1 id="Currying+And+Partial+Application">Currying And Partial Application</h1><p>Currying is the process of taking a method with N parameters and turning it into one with N parameter groups. 
</p><pre><code class="prettyprint lang-scala">val addValues = (first: Int, second: Int) =&gt; first + second
val curriedAddValues = addValues.curried

println(addValues(1, 2))
println(curriedAddValues(1)(2))

val addFour = curriedAddValues(4)
println(addFour(9))

// Also:
val otherAddFour = addValues(_: Int, 4)
println(otherAddFour(23))
</code></pre><h1 id="Either">Either</h1><p><a  href="http://www.scala-lang.org/api/current/scala/Either.html">Either</a> is a type somewhat like Option, except that instead of one value or no value, it holds one value or another value of potentially differing types.
</p><pre><code class="prettyprint lang-scala">val left: Either[String, Int] = Left(&quot;There was an error.&quot;)
val right: Either[String, Int] = Right(9)
println(left)
println(right)
</code></pre><p>This is useful for encoding a success (by convention a Right) or a failure (Left), being that they are case classes it’s possible to pattern match on them.
</p><pre><code class="prettyprint lang-scala">case class Player(name: String)
def lookupUser(playerID: Int): Either[String, Player] = {
  if (playerID == 1) {
    Right(Player(&quot;Sean&quot;))
  } else {
    Left(&quot;Player %s could not be found.&quot;.format(playerID))
  }
}
println(lookupUser(1))
println(lookupUser(2))
</code></pre><h1 id="Java+Interop">Java Interop</h1><p>Scala works pretty much interoperably with Java, there are just a couple of things to be careful of.
<br/>
<br/>
Using Java libraries/code in Scala should be pretty much seamless, the only thing that will become a necessity will be the use of the <a  href="http://www.scala-lang.org/api/current/scala/collection/JavaConverters$.html">JavaConverters</a> object.
<br/>
<br/>
Using Scala libraries/code from Java will potentially necessitate avoiding features of Scala that don’t map well to Java, implicit and multiple parameter groups as well as functions will be awkward at best. In this case it would be advised to create additional methods using Scala to shield off these difficulties and provide interfaces that are more Java like.
</p><h1 id="Actors">Actors</h1><p>In which we explore actors using <a  href="http://akka.io/">Akka</a>.
<br />
<br />
Note to run these examples in the REPL, you’ll need to include an Akka 2.0 actor jar in the classpath and pass the ”-Yrepl-sync” option to the REPL.
<br />
<br />
Note that while Scala includes an actor implementation in the core library, in the future they will be replaced by Akka actors.
<br />
<br />
<a  href="http://akka.io/docs/">The Akka Documentation</a> is much more comprehensive than this, this is more of an introduction to what can be done.
</p><h1 id="What%E2%80%99s+an+actor%3F">What’s an actor?</h1><pre><code class="prettyprint lang-scala">import akka.actor._

val actorSystem = ActorSystem(&quot;actorSystem&quot;)
case class TestActor() extends Actor {
  def receive = {
    case &quot;Kitteh&quot; =&gt; println(&quot;Kitteh received, over and out.&quot;)
    case _ =&gt; println(&quot;Unknown received.&quot;)
  }
}

val actorRef = actorSystem.actorOf(Props[TestActor], 
  name = &quot;testActor&quot;)
actorRef.tell(&quot;Kitteh&quot;)
actorRef ! &quot;Dog&quot;
actorSystem.shutdown()
</code></pre><p>Instances of actors are independent, only process one message at a time and queue said messages in a mailbox.
</p><h1 id="What+If+I+Want+A+Result%3F">What If I Want A Result?</h1><pre><code class="prettyprint lang-scala">import akka.actor._
import akka.util.Timeout
import akka.util.duration._
import akka.pattern._

val actorSystem = ActorSystem(&quot;actorSystem&quot;)
case class ReplyActor() extends Actor {
  def receive = {
    case int: Int =&gt; {
      Thread.sleep(200)
      sender ! &quot;Received Int: %s&quot;.format(int)
    }
    case _ =&gt; sender ! &quot;Unknown received.&quot;
  }
}

val actorRef = actorSystem.actorOf(Props[ReplyActor], 
  name = &quot;replyActor&quot;)
implicit val timeout = Timeout(5 seconds)
val future = actorRef ? 2000
println(future.value)    // Should be None.
Thread.sleep(400)
println(future.value)    // Should be Some(Right(...))
actorSystem.shutdown()
</code></pre><h1 id="Don%E2%80%99t+Block%21">Don’t Block!</h1><pre><code class="prettyprint lang-scala">import akka.actor._
import akka.util.Timeout
import akka.util.duration._
import akka.pattern._

val actorSystem = ActorSystem(&quot;actorSystem&quot;)
case class ReplyActor() extends Actor {
  def receive = {
    case int: Int =&gt; {
      Thread.sleep(200)
      sender ! &quot;Received Int: %s&quot;.format(int)
    }
    case _ =&gt; sender ! &quot;Unknown received.&quot;
  }
}

val actorRef = actorSystem.actorOf(Props[ReplyActor], 
  name = &quot;replyActor&quot;)
implicit val timeout = Timeout(5 seconds)
val future = actorRef ? 2000
future.onComplete{
  case Right(result) =&gt; println(result)
  case _ =&gt; println(&quot;Uh oh!&quot;)
}
actorSystem.shutdown()
</code></pre><h1 id="Where+Would+I+Use+Actors%3F">Where Would I Use Actors?</h1><p>If you want to avoid manually controlling synchronisation around some piece of state, it’s possible to use the actor to hold the state and manage that for you.
<br />
<br />
It’s possible to create and start hundreds of thousands, if not millions of actors on one machine, while not processing messages they don’t consume any CPU time.
</p><h1 id="SBT">SBT</h1><p>In which we discuss <a  href="https://github.com/harrah/xsbt">Simple Build Tool</a>.
</p><h1 id="Getting+SBT+Installed">Getting SBT Installed</h1><ul><li>Download <a  href="https://raw.github.com/paulp/sbt-extras/master/sbt">this</a> Bash script from the <a  href="https://github.com/paulp/sbt-extras">SBT Extras</a> repo.
</li><li>Place that script on your PATH or in the root of your project and run it from the root of your project.
</li><li>Make the magic happen.
</li></ul><h1 id="SBT+Basics">SBT Basics</h1><p>SBT is run similarly to <a  href="http://ant.apache.org/">Ant</a> or <a  href="http://maven.apache.org/">Maven</a> via a series of commands that you add on the end of the command line:
</p><pre><code class="">$ sbt clean
[info] Loading global plugins from /Users/Sean/.sbt/plugins
[info] Set current project to default-66315d (in build file:/Users/Sean/test/)
[success] Total time: 0 s, completed Feb 15, 2012 12:24:21 PM
</code></pre><p>SBT also supports being run interactively if no commands are specified:
</p><pre><code class="">$ sbt
[info] Loading global plugins from /Users/Sean/.sbt/plugins
[info] Set current project to default-66315d (in build file:/Users/Sean/test/)
&gt; clean
[success] Total time: 0 s, completed Feb 15, 2012 12:25:07 PM
&gt;
</code></pre>
          </div>
        </div>
        
      </body>
    </html>